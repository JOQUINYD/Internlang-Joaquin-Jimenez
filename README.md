# Internlang-Joaquin-Jimenez

## General structure ##

The general structure of the system consists of three main packages:
1. Compiler
2. CodeGenerator
3. UIGenerator

You can visualize the system's structure in the PDF file "Internlang UML."

### Compiler Structure ###

There is a Compiler class, which is responsible for compiling any given code in a specific language. It must follow a step-by-step process until it has the necessary information to generate new code. This process is triggered by the method: compile(code, targetCode), where code is the input code, and targetCode is an ENUM specifying the language to convert the code. 

The first step in this process is the lexical analysis of the input code. The system has a Lexer class responsible for creating an ArrayList of Tokens. A token is a class.

The second step is syntax analysis. The system has a Parser class. The parser uses the ArrayList of Tokens generated by the Lexer to construct the SymbolTable and ParseTree. The SymbolTable and ParseTree are classes.

The third step is semantic analysis. The system has a SemanticAnalyzer class, that uses the SymbolTable and ParseTree generated by the Parse and verifies that it is correct.

The final step is generating the code with a CodeGenerator.


### Code generation structure ###

The system has a general CodeGenerator Interface that each specific CodeGenerator will implement. Thus, all specific CodeGenerators need to implement the methods stated in the Interface. 

The method generate(ParseTree, SymbolTree) will generate the code for its specific language and returns it as a String, based on the information passed through the SymbolTable and ParseTree defined in the previous steps.

For this initial structure, four specific CodeGenerators were defined:
* PythonCodeGenerator
* JavaCodeGenerator
* CsharpCodeGenerator
* TypescriptCodeGenerator.

Each has an UIGenerator, which will generate UI elements based on its language libraries.


### UI elements generation structure ###

All UIGenerators need to implement the UIGenerator Interface, where methods to create UI elements are defined. For example, createButton() or createWindow().
 
Each language has its own UIGenerator: 
* PythonUIGenerator
* JavaUIGenerator
* CsharpUIGenerator
* TypescriptUIGenerator

All UI elements will implement the Interface UIElement. Each element, for example, UIButton and UIWindow, will extend from UIElement.

The system needs specific UIElements for each language. In the case of UIButton and UIWindow, each language must have its own Button and Window class. For example, Python will have a PythonButton class and PythonWindow class.

A CodeGenerator has an UIGenerator specific for its language. For example, the PythonCodeGenerator has an UIGenerator such as uiGenerator = new PythonUIGenerator. Since all specific UIGenerators are of type UIGenerator, they can create UIElements using the same methods; However, these methods will behave differently for each language.


